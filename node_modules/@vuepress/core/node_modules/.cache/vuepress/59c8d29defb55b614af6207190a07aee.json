{"remainingRequest":"D:\\vp2\\node_modules\\babel-loader\\lib\\index.js??ref--3-1!D:\\vp2\\node_modules\\@vuepress\\core\\lib\\app\\util.js","dependencies":[{"path":"D:\\vp2\\node_modules\\@vuepress\\core\\lib\\app\\util.js","mtime":1549712920177},{"path":"D:\\vp2\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1547842182214},{"path":"D:\\vp2\\node_modules\\babel-loader\\lib\\index.js","mtime":1547849720006}],"contextDependencies":[],"result":["import _typeof from \"D:\\\\vp2\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/typeof\";\nimport _toConsumableArray from \"D:\\\\vp2\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/toConsumableArray\";\nimport \"core-js/modules/es6.function.name\";\nimport \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"D:\\\\vp2\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport \"core-js/modules/es6.array.filter\";\nimport \"core-js/modules/es6.array.map\";\nimport _Promise from \"D:\\\\vp2\\\\node_modules\\\\@babel\\\\runtime-corejs2/core-js/promise\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport _Object$assign from \"D:\\\\vp2\\\\node_modules\\\\@babel\\\\runtime-corejs2/core-js/object/assign\";\nimport Vue from 'vue';\nimport layoutComponents from '@internal/layout-components';\nimport pageComponents from '@internal/page-components';\n\nvar asyncComponents = _Object$assign({}, layoutComponents, pageComponents);\n\nexport function isPageExists(pageKey) {\n  return Boolean(pageComponents[pageKey]);\n}\nexport function isPageLoaded(pageKey) {\n  return Boolean(Vue.component(pageKey));\n}\nexport function getPageAsyncComponent(pageKey) {\n  return pageComponents[pageKey];\n}\nexport function isLayoutExists(layout) {\n  return Boolean(layoutComponents[layout]);\n}\nexport function isLayoutLoaded(layout) {\n  return Boolean(Vue.component(layout));\n}\nexport function getLayoutAsyncComponent(pageKey) {\n  return layoutComponents[pageKey];\n}\nexport function ensureAsyncComponentsLoaded() {\n  for (var _len = arguments.length, names = new Array(_len), _key = 0; _key < _len; _key++) {\n    names[_key] = arguments[_key];\n  }\n\n  return _Promise.all(names.filter(function (v) {\n    return v;\n  }).map(\n  /*#__PURE__*/\n  function () {\n    var _ref = _asyncToGenerator(\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function _callee(name) {\n      var comp;\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(!Vue.component(name) && asyncComponents[name])) {\n                _context.next = 5;\n                break;\n              }\n\n              _context.next = 3;\n              return asyncComponents[name]();\n\n            case 3:\n              comp = _context.sent;\n              Vue.component(name, comp.default);\n\n            case 5:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }()));\n}\n/**\n * Inject option to Vue SFC\n * @param {object} options\n * @param {string} key\n * @param {any} value\n */\n\nexport function injectComponentOption(options, key, value) {\n  var arrayInject = function arrayInject() {\n    var _options$key;\n\n    if (!options[key]) options[key] = [];\n\n    (_options$key = options[key]).push.apply(_options$key, _toConsumableArray(value));\n  };\n\n  var objectInject = function objectInject() {\n    if (!options[key]) options[key] = {};\n\n    _Object$assign(options[key], value);\n  }; // const primitiveInject = () => options[key] = value\n\n\n  switch (key) {\n    case 'components':\n      objectInject();\n      break;\n\n    case 'mixins':\n      arrayInject();\n      break;\n\n    default:\n      throw new Error('Unknown option name.');\n  }\n}\nexport function findPageForPath(pages, path) {\n  for (var i = 0; i < pages.length; i++) {\n    var page = pages[i];\n\n    if (page.path === path) {\n      return page;\n    }\n  }\n\n  return {\n    path: '',\n    frontmatter: {}\n  };\n}\nexport function findPageByKey(pages, key) {\n  for (var i = 0; i < pages.length; i++) {\n    var page = pages[i];\n\n    if (page.key === key) {\n      return page;\n    }\n  }\n\n  return {\n    path: '',\n    frontmatter: {}\n  };\n}\n/**\n * Normalize config.\n * This utility is mainly for plugin developers. For some\n * plugins that need internationalize the text. but it's\n * not recommenbded to let plugin care about to the internal\n * i18n implementation, so this utility was born.\n *\n *\n * Usage:\n *\n * import { normalizeConfig } from '@app/util'\n * export default {\n *   data () {\n *     return { config }\n *   }\n *   computed: {\n *     normalizedConfig() {\n *       return normalizeConfig(this, config)\n *     }\n *   }\n * }\n *\n *\n * e.g.\n *\n * Config: : 'Text'\n * Normalized Config: 'Text'\n *\n * Config: : { '/': 'Text', '/zh/': '文本' }\n * Normalized Config: 'Text' or '文本'\n *\n * @param {Vue} component\n * @param {any} rawConfig\n * @returns {any}\n */\n\nexport function normalizeConfig(component, rawConfig) {\n  var $localePath = component.$localePath;\n\n  if (_typeof(rawConfig) === 'object' && rawConfig[$localePath]) {\n    return rawConfig[$localePath];\n  }\n\n  return rawConfig;\n}",null]}