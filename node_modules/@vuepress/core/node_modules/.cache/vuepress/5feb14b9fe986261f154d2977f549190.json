{"remainingRequest":"D:\\vp2\\node_modules\\babel-loader\\lib\\index.js??ref--3-1!D:\\vp2\\node_modules\\@vuepress\\core\\lib\\app\\util.js","dependencies":[{"path":"D:\\vp2\\node_modules\\@vuepress\\core\\lib\\app\\util.js","mtime":1549712920177},{"path":"D:\\vp2\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1547842182214},{"path":"D:\\vp2\\node_modules\\babel-loader\\lib\\index.js","mtime":1547849720006}],"contextDependencies":[],"result":["import _typeof from \"D:\\\\vp2\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/typeof\";\nimport _toConsumableArray from \"D:\\\\vp2\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/toConsumableArray\";\nimport \"core-js/modules/es6.function.name\";\nimport \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"D:\\\\vp2\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport \"core-js/modules/es6.array.filter\";\nimport \"core-js/modules/es6.array.map\";\nimport _Promise from \"D:\\\\vp2\\\\node_modules\\\\@babel\\\\runtime-corejs2/core-js/promise\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.string.iterator\";\nimport _Object$assign from \"D:\\\\vp2\\\\node_modules\\\\@babel\\\\runtime-corejs2/core-js/object/assign\";\nimport Vue from 'vue';\nimport layoutComponents from '@internal/layout-components';\nimport pageComponents from '@internal/page-components';\n\nvar asyncComponents = _Object$assign({}, layoutComponents, pageComponents);\n\nexport function isPageExists(pageKey) {\n  return Boolean(pageComponents[pageKey]);\n}\nexport function isPageLoaded(pageKey) {\n  return Boolean(Vue.component(pageKey));\n}\nexport function getPageAsyncComponent(pageKey) {\n  return pageComponents[pageKey];\n}\nexport function isLayoutExists(layout) {\n  return Boolean(layoutComponents[layout]);\n}\nexport function isLayoutLoaded(layout) {\n  return Boolean(Vue.component(layout));\n}\nexport function getLayoutAsyncComponent(pageKey) {\n  return layoutComponents[pageKey];\n}\nexport function ensureAsyncComponentsLoaded() {\n  for (var _len = arguments.length, names = new Array(_len), _key = 0; _key < _len; _key++) {\n    names[_key] = arguments[_key];\n  }\n\n  return _Promise.all(names.filter(function (v) {\n    return v;\n  }).map(\n  /*#__PURE__*/\n  function () {\n    var _ref = _asyncToGenerator(\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function _callee(name) {\n      var comp;\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(!Vue.component(name) && asyncComponents[name])) {\n                _context.next = 5;\n                break;\n              }\n\n              _context.next = 3;\n              return asyncComponents[name]();\n\n            case 3:\n              comp = _context.sent;\n              Vue.component(name, comp.default);\n\n            case 5:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }()));\n}\n/**\n * Inject option to Vue SFC\n * @param {object} options\n * @param {string} key\n * @param {any} value\n */\n\nexport function injectComponentOption(options, key, value) {\n  var arrayInject = function arrayInject() {\n    var _options$key;\n\n    if (!options[key]) options[key] = [];\n\n    (_options$key = options[key]).push.apply(_options$key, _toConsumableArray(value));\n  };\n\n  var objectInject = function objectInject() {\n    if (!options[key]) options[key] = {};\n\n    _Object$assign(options[key], value);\n  }; // const primitiveInject = () => options[key] = value\n\n\n  switch (key) {\n    case 'components':\n      objectInject();\n      break;\n\n    case 'mixins':\n      arrayInject();\n      break;\n\n    default:\n      throw new Error('Unknown option name.');\n  }\n}\nexport function findPageForPath(pages, path) {\n  for (var i = 0; i < pages.length; i++) {\n    var page = pages[i];\n\n    if (page.path === path) {\n      return page;\n    }\n  }\n\n  return {\n    path: '',\n    frontmatter: {}\n  };\n}\nexport function findPageByKey(pages, key) {\n  for (var i = 0; i < pages.length; i++) {\n    var page = pages[i];\n\n    if (page.key === key) {\n      return page;\n    }\n  }\n\n  return {\n    path: '',\n    frontmatter: {}\n  };\n}\n/**\n * Normalize config.\n * This utility is mainly for plugin developers. For some\n * plugins that need internationalize the text. but it's\n * not recommenbded to let plugin care about to the internal\n * i18n implementation, so this utility was born.\n *\n *\n * Usage:\n *\n * import { normalizeConfig } from '@app/util'\n * export default {\n *   data () {\n *     return { config }\n *   }\n *   computed: {\n *     normalizedConfig() {\n *       return normalizeConfig(this, config)\n *     }\n *   }\n * }\n *\n *\n * e.g.\n *\n * Config: : 'Text'\n * Normalized Config: 'Text'\n *\n * Config: : { '/': 'Text', '/zh/': '文本' }\n * Normalized Config: 'Text' or '文本'\n *\n * @param {Vue} component\n * @param {any} rawConfig\n * @returns {any}\n */\n\nexport function normalizeConfig(component, rawConfig) {\n  var $localePath = component.$localePath;\n\n  if (_typeof(rawConfig) === 'object' && rawConfig[$localePath]) {\n    return rawConfig[$localePath];\n  }\n\n  return rawConfig;\n}",{"version":3,"sources":["D:\\vp2\\node_modules\\@vuepress\\core\\lib\\app\\util.js"],"names":["Vue","layoutComponents","pageComponents","asyncComponents","isPageExists","pageKey","Boolean","isPageLoaded","component","getPageAsyncComponent","isLayoutExists","layout","isLayoutLoaded","getLayoutAsyncComponent","ensureAsyncComponentsLoaded","names","all","filter","v","map","name","comp","default","injectComponentOption","options","key","value","arrayInject","push","objectInject","Error","findPageForPath","pages","path","i","length","page","frontmatter","findPageByKey","normalizeConfig","rawConfig","$localePath"],"mappings":"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","sourcesContent":["import Vue from 'vue'\nimport layoutComponents from '@internal/layout-components'\nimport pageComponents from '@internal/page-components'\n\nconst asyncComponents = Object.assign({}, layoutComponents, pageComponents)\n\nexport function isPageExists (pageKey) {\n  return Boolean(pageComponents[pageKey])\n}\n\nexport function isPageLoaded (pageKey) {\n  return Boolean(Vue.component(pageKey))\n}\n\nexport function getPageAsyncComponent (pageKey) {\n  return pageComponents[pageKey]\n}\n\nexport function isLayoutExists (layout) {\n  return Boolean(layoutComponents[layout])\n}\n\nexport function isLayoutLoaded (layout) {\n  return Boolean(Vue.component(layout))\n}\n\nexport function getLayoutAsyncComponent (pageKey) {\n  return layoutComponents[pageKey]\n}\n\nexport function ensureAsyncComponentsLoaded (...names) {\n  return Promise.all(names.filter(v => v).map(async (name) => {\n    if (!Vue.component(name) && asyncComponents[name]) {\n      const comp = await asyncComponents[name]()\n      Vue.component(name, comp.default)\n    }\n  }))\n}\n\n/**\n * Inject option to Vue SFC\n * @param {object} options\n * @param {string} key\n * @param {any} value\n */\nexport function injectComponentOption (options, key, value) {\n  const arrayInject = () => {\n    if (!options[key]) options[key] = []\n    options[key].push(...value)\n  }\n  const objectInject = () => {\n    if (!options[key]) options[key] = {}\n    Object.assign(options[key], value)\n  }\n  // const primitiveInject = () => options[key] = value\n\n  switch (key) {\n  case 'components': objectInject(); break\n  case 'mixins': arrayInject(); break\n  default: throw new Error('Unknown option name.')\n  }\n}\n\nexport function findPageForPath (pages, path) {\n  for (let i = 0; i < pages.length; i++) {\n    const page = pages[i]\n    if (page.path === path) {\n      return page\n    }\n  }\n  return {\n    path: '',\n    frontmatter: {}\n  }\n}\n\nexport function findPageByKey (pages, key) {\n  for (let i = 0; i < pages.length; i++) {\n    const page = pages[i]\n    if (page.key === key) {\n      return page\n    }\n  }\n  return {\n    path: '',\n    frontmatter: {}\n  }\n}\n\n/**\n * Normalize config.\n * This utility is mainly for plugin developers. For some\n * plugins that need internationalize the text. but it's\n * not recommenbded to let plugin care about to the internal\n * i18n implementation, so this utility was born.\n *\n *\n * Usage:\n *\n * import { normalizeConfig } from '@app/util'\n * export default {\n *   data () {\n *     return { config }\n *   }\n *   computed: {\n *     normalizedConfig() {\n *       return normalizeConfig(this, config)\n *     }\n *   }\n * }\n *\n *\n * e.g.\n *\n * Config: : 'Text'\n * Normalized Config: 'Text'\n *\n * Config: : { '/': 'Text', '/zh/': '文本' }\n * Normalized Config: 'Text' or '文本'\n *\n * @param {Vue} component\n * @param {any} rawConfig\n * @returns {any}\n */\nexport function normalizeConfig (component, rawConfig) {\n  const { $localePath } = component\n  if (typeof rawConfig === 'object' && rawConfig[$localePath]) {\n    return rawConfig[$localePath]\n  }\n  return rawConfig\n}\n"]}]}